# プラグイン開発ガイド

## 概要 🚀

このドキュメントではedvプラグインの開発方法について説明します。開発環境のセットアップから基本的なプラグイン実装、テスト、配布までの一連の流れを解説します。

最終更新日: 2025年4月1日

## 開発環境のセットアップ 🛠️

### 必要なツール

- Rust (1.65以上)
- Cargo
- edv-plugin-sdk

### インストール手順

```bash
# Rustツールチェーンのインストール (未インストールの場合)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# edvプラグイン開発キットのインストール
cargo install edv-plugin-sdk

# プラグインテンプレートの生成
edv-plugin-sdk new my-awesome-plugin
cd my-awesome-plugin
```

## プラグインの基本構造 📂

生成されたプラグインテンプレートは以下のような構造になっています：

```
my-awesome-plugin/
├── Cargo.toml              # 依存関係と設定
├── plugin.toml             # プラグインマニフェスト
├── src/
│   ├── lib.rs              # プラグインのエントリーポイント
│   ├── plugin.rs           # Pluginトレイト実装
│   └── effect.rs           # 実際のプラグイン機能実装
├── resources/              # リソースファイル
└── tests/                  # テストファイル
```

### マニフェストファイル

```toml
# plugin.toml
[plugin]
id = "com.example.my-awesome-plugin"
name = "My Awesome Plugin"
version = "0.1.0"
author = "Your Name"
description = "This plugin does awesome things"
api_version = "1.0"
plugin_type = "effect"

[dependencies]
# 依存するプラグインがあれば記述

[capabilities]
has_settings_ui = true
supports_hot_reload = false
supports_async = true
supports_gpu = false
thread_safe = true
```

## プラグインの実装 💻

### 基本的なプラグイン実装

```rust
// lib.rs
mod plugin;
mod effect;

// プラグインファクトリ関数
#[no_mangle]
pub extern "C" fn create_plugin() -> *mut dyn edv_plugin_api::Plugin {
    let plugin = plugin::MyAwesomePlugin::default();
    Box::into_raw(Box::new(plugin))
}

// plugin.rs
use edv_plugin_api::*;
use std::collections::HashMap;

#[derive(Default)]
pub struct MyAwesomePlugin {
    host: Option<Box<dyn PluginHost>>,
}

impl Plugin for MyAwesomePlugin {
    fn id(&self) -> &str {
        "com.example.my-awesome-plugin"
    }
    
    fn name(&self) -> &str {
        "My Awesome Plugin"
    }
    
    fn version(&self) -> (u32, u32, u32) {
        (0, 1, 0)
    }
    
    fn author(&self) -> &str {
        "Your Name"
    }
    
    fn description(&self) -> &str {
        "This plugin does awesome things"
    }
    
    fn initialize(&mut self, host: Box<dyn PluginHost>) -> Result<(), PluginError> {
        host.logger().info("MyAwesomePlugin を初期化中...");
        self.host = Some(host);
        Ok(())
    }
    
    fn shutdown(&mut self) -> Result<(), PluginError> {
        if let Some(host) = &self.host {
            host.logger().info("MyAwesomePlugin をシャットダウン中...");
        }
        Ok(())
    }
    
    fn plugin_type(&self) -> PluginType {
        PluginType::Effect
    }
    
    fn api_version(&self) -> (u32, u32) {
        (1, 0)
    }
    
    fn capabilities(&self) -> PluginCapabilities {
        PluginCapabilities {
            has_settings_ui: true,
            supports_hot_reload: false,
            supports_async: true,
            supports_gpu: false,
            thread_safe: true,
        }
    }
}

// エフェクトプラグインの場合の実装例
impl VideoEffectPlugin for MyAwesomePlugin {
    fn apply_effect(&self, 
                  frame: &mut VideoFrame,
                  parameters: &HashMap<String, EffectParameter>,
                  _context: &EffectContext) -> Result<(), PluginError> {
        // エフェクト処理の実装
        for y in 0..frame.height() {
            for x in 0..frame.width() {
                let pixel = frame.get_pixel(x, y)?;
                // ピクセル処理（例：明るさ調整）
                let brightness = if let Some(EffectParameter::Float(value)) = parameters.get("brightness") {
                    *value
                } else {
                    1.0 // デフォルト値
                };
                
                let r = (pixel.r as f32 * brightness).min(255.0) as u8;
                let g = (pixel.g as f32 * brightness).min(255.0) as u8;
                let b = (pixel.b as f32 * brightness).min(255.0) as u8;
                
                frame.set_pixel(x, y, Pixel { r, g, b, a: pixel.a })?;
            }
        }
        
        Ok(())
    }
    
    fn get_parameters(&self) -> Vec<EffectParameterDefinition> {
        vec![
            EffectParameterDefinition {
                id: "brightness".into(),
                name: "明るさ".into(),
                description: "画像の明るさを調整します".into(),
                parameter_type: EffectParameterType::Float,
                default_value: EffectParameter::Float(1.0),
                min_value: Some(EffectParameter::Float(0.0)),
                max_value: Some(EffectParameter::Float(2.0)),
                step: Some(EffectParameter::Float(0.1)),
            }
        ]
    }
}
```

## プラグインの種類別実装例 🧩

### 1. エフェクトプラグイン

エフェクトプラグインは、ビデオやオーディオに効果を適用します。

```rust
// ビデオエフェクトの例：セピアトーン
fn apply_sepia_effect(frame: &mut VideoFrame) -> Result<(), PluginError> {
    for y in 0..frame.height() {
        for x in 0..frame.width() {
            let pixel = frame.get_pixel(x, y)?;
            
            // セピアトーン変換
            let r = pixel.r;
            let g = pixel.g;
            let b = pixel.b;
            
            let new_r = (0.393 * r as f32 + 0.769 * g as f32 + 0.189 * b as f32).min(255.0) as u8;
            let new_g = (0.349 * r as f32 + 0.686 * g as f32 + 0.168 * b as f32).min(255.0) as u8;
            let new_b = (0.272 * r as f32 + 0.534 * g as f32 + 0.131 * b as f32).min(255.0) as u8;
            
            frame.set_pixel(x, y, Pixel { r: new_r, g: new_g, b: new_b, a: pixel.a })?;
        }
    }
    
    Ok(())
}
```

### 2. エクスポータープラグイン

エクスポータープラグインは、カスタムフォーマットへのエクスポート機能を提供します。

```rust
impl ExporterPlugin for MyExporterPlugin {
    fn supported_formats(&self) -> Vec<ExportFormat> {
        vec![
            ExportFormat {
                id: "custom-format".to_string(),
                name: "カスタムフォーマット".to_string(),
                description: "独自の動画フォーマット".to_string(),
                file_extensions: vec!["cfv".to_string()],
            }
        ]
    }
    
    fn begin_export(&mut self, 
                   target_path: &Path,
                   format: &str,
                   options: &HashMap<String, ExportOptionValue>,
                   context: &ExportContext) -> Result<(), PluginError> {
        // エクスポート開始処理
        // ファイルを開く、ヘッダーを書き込むなど
        self.output_file = Some(std::fs::File::create(target_path)?);
        self.write_header(context.width(), context.height(), context.fps())?;
        Ok(())
    }
    
    fn export_frame(&mut self, 
                   frame: &VideoFrame,
                   timestamp: f64) -> Result<(), PluginError> {
        // フレームデータの書き込み
        if let Some(file) = &mut self.output_file {
            // フレームデータのエンコードと書き込み
            // ...
        }
        Ok(())
    }
    
    // その他の必要なメソッド実装...
}
```

## UI拡張 🖼️

プラグインにUIを追加する場合、UIプラグインインターフェースを実装します。

```rust
impl UserInterfacePlugin for MyUiPlugin {
    fn register_components(&self, registry: &mut dyn UiComponentRegistry) -> Result<(), PluginError> {
        // カスタムUIコンポーネントの登録
        registry.register_component("my-custom-panel", self.create_custom_panel())?;
        Ok(())
    }
    
    fn provide_panels(&self) -> Vec<UiPanelDefinition> {
        vec![
            UiPanelDefinition {
                id: "my-plugin-panel".to_string(),
                title: "マイプラグインパネル".to_string(),
                component_id: "my-custom-panel".to_string(),
                default_position: PanelPosition::Right,
                default_size: (300, 400),
                min_size: Some((200, 200)),
                icon: Some("panel-icon.svg".to_string()),
            }
        ]
    }
    
    fn provide_menu_items(&self) -> Vec<MenuItem> {
        vec![
            MenuItem {
                id: "my-plugin-menu-item".to_string(),
                label: "マイプラグイン機能".to_string(),
                parent: Some("tools".to_string()),
                shortcut: Some("Ctrl+Shift+M".to_string()),
                icon: Some("menu-icon.svg".to_string()),
                action: MenuAction::Callback("my-plugin.action".to_string()),
            }
        ]
    }
}
```

## ビルドとテスト 🧪

### プラグインのビルド

```bash
# デバッグビルド
cargo build

# リリースビルド
cargo build --release
```

### テスト実行

```bash
# テストの実行
cargo test

# 特定のテストを実行
cargo test test_effect_application
```

### プラグインのテスト方法

1. **単体テスト**:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       
       #[test]
       fn test_effect_application() {
           // テストフレームの作成
           let mut frame = create_test_frame(640, 480);
           
           // エフェクト適用
           let params = HashMap::new();
           let effect = MyAwesomePlugin::default();
           let context = create_test_context();
           
           let result = effect.apply_effect(&mut frame, &params, &context);
           assert!(result.is_ok());
           
           // 結果の検証
           // ...
       }
   }
   ```

2. **インテグレーションテスト**:
   - edv-plugin-sdkにはプラグインをホストアプリケーションなしでテストするためのモックホスト実装が含まれています
   - `cargo run --example mock_host -- --plugin-path=./target/debug/libmy_awesome_plugin.so`

## デバッグ方法 🐛

### ログ出力

```rust
// プラグイン内でのログ出力
fn some_method(&self) -> Result<(), PluginError> {
    if let Some(host) = &self.host {
        let logger = host.logger();
        
        logger.debug("デバッグ情報"); // 開発時のみ表示
        logger.info("情報メッセージ"); // 通常の情報
        logger.warn("警告メッセージ"); // 問題があるが致命的ではない
        logger.error("エラーメッセージ"); // 深刻な問題
    }
    
    Ok(())
}
```

### デバッグモードでの実行

```bash
# デバッグ情報を有効にしてedvを実行
EDV_PLUGIN_DEBUG=1 edv

# 特定のプラグインのみデバッグ情報を有効化
EDV_PLUGIN_DEBUG=com.example.my-awesome-plugin edv
```

### 一般的なデバッグのヒント

1. **段階的な開発**: 小さな機能から実装し、段階的にテストする
2. **エラー処理**: すべてのエラーケースを適切に処理し、具体的なエラーメッセージを提供する
3. **リソース管理**: リソースの確保と解放を適切に行い、メモリリークを防ぐ
4. **境界条件のテスト**: エッジケースや異常なパラメータでのテストを実施する

## プラグインの配布 📦

### パッケージング

```bash
# プラグインのパッケージング
edv-plugin-sdk package

# 特定のプラットフォーム向けにパッケージング
edv-plugin-sdk package --platform windows
edv-plugin-sdk package --platform linux
edv-plugin-sdk package --platform macos
```

### パッケージ構造

```
my-awesome-plugin-0.1.0/
├── plugin.toml                  # マニフェスト
├── libmy_awesome_plugin.so      # Linux用バイナリ
├── my_awesome_plugin.dll        # Windows用バイナリ
├── libmy_awesome_plugin.dylib   # macOS用バイナリ
├── README.md                    # ドキュメント
└── resources/                   # リソースファイル
```

### プラグインストアへの公開

1. edvプラグインストアアカウントを作成
2. 開発者証明書を取得
3. プラグインに署名
   ```bash
   edv-plugin-sdk sign --key developer-key.pem
   ```
4. ストアにアップロード
   ```bash
   edv-plugin-sdk publish
   ```

## トラブルシューティング 🔧

### 一般的な問題と解決策

1. **プラグインが読み込まれない**
   - マニフェストファイルが正しく設定されているか確認
   - APIバージョンの互換性を確認
   - 依存関係が揃っているか確認

2. **初期化中にクラッシュする**
   - 初期化時の例外処理を確認
   - リソース確保が適切か確認
   - ホストAPIの使用方法が正しいか確認

3. **パフォーマンス問題**
   - 処理の最適化
   - 大きなフレームでのメモリ使用を確認
   - リソースのキャッシュを考慮

## ベストプラクティス ✨

1. **最小権限の原則**: 必要最小限の権限のみを要求する
2. **エラー処理**: すべてのエラーを適切に処理し、ユーザーフレンドリーなメッセージを提供する
3. **リソース管理**: リソースを適切に確保・解放し、メモリリークを防ぐ
4. **ドキュメント**: 機能とオプションを明確に文書化する
5. **国際化**: UIテキストとエラーメッセージの国際化を考慮する
6. **バージョン互換性**: APIの変更時は互換性を考慮する

## 関連ドキュメント 📚

- [01_プラグイン基本設計.md](./01_プラグイン基本設計.md) - プラグインシステムの基本設計
- [02_プラグインインターフェース.md](./02_プラグインインターフェース.md) - プラグインAPI
- [03_プラグインライフサイクル.md](./03_プラグインライフサイクル.md) - プラグインのライフサイクル
- [04_プラグインセキュリティ.md](./04_プラグインセキュリティ.md) - セキュリティモデル 
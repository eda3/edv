# edv - 統合テスト戦略

このドキュメントでは、edvプロジェクトの統合テストアプローチについて詳述し、複数のコンポーネントとモジュール間の相互作用を検証します。

## 統合テスト概要

統合テストは、システムの異なる部分が正しく連携することを検証します：

- **スコープ**：複数の相互作用するモジュールとサブシステム
- **実際の依存関係**：可能な限り実際の依存関係を使用
- **ステータス**：現在計画段階にあり、将来の反復で実装予定
- **ターゲット**：CLI、Processing、FFmpegなどの主要モジュール間の相互作用を検証

## 計画された実装構造

### ディレクトリ構成

統合テストは専用の`tests/`ディレクトリに整理されます：

```
tests/
├── cli_tests.rs        // CLI統合テスト
├── processing_tests.rs // 処理パイプラインテスト
├── project_tests.rs    // プロジェクト管理テスト
├── asset_tests.rs      // アセット処理テスト
└── common/             // 共有テストユーティリティ
    ├── mod.rs
    ├── test_utils.rs
    └── test_fixtures.rs
```

### テスト実装パターン

統合テストは一貫したパターンに従います：

```rust
// tests/processing_tests.rsの将来の例
use edv::core::config::AppConfig;
use edv::processing::pipeline::ProcessingPipeline;
use edv::processing::operations::trim::TrimOperation;
use std::path::Path;

#[test]
fn test_trim_video_integration() {
    // セットアップ：実際の実装でコンポーネントを初期化
    let config = AppConfig::load_default().unwrap();
    let pipeline = ProcessingPipeline::new(config.clone()).unwrap();
    
    // テストデータを準備
    let input_path = Path::new("test_fixtures/sample.mp4");
    let output_path = tempfile::NamedTempFile::new().unwrap();
    
    // 操作を作成
    let trim_op = TrimOperation::new(
        input_path,
        output_path.path(),
        Some(TimePosition::from_seconds(1.0)),
        Some(TimePosition::from_seconds(3.0)),
        true,
    );
    
    // 操作を実行
    let result = pipeline.execute(Box::new(trim_op), None);
    assert!(result.is_ok());
    
    // 結果を検証
    let output_info = pipeline.get_media_info(output_path.path()).unwrap();
    assert!(output_info.duration.unwrap().to_seconds() - 2.0 < 0.1);
}
```

### テストフィクスチャ

- プロジェクトでは、様々な特性を持つテスト用ビデオファイルのコレクションを維持します
- 異なるフォーマット、コーデック、解像度、および長さのファイルが含まれます
- テストフィクスチャはテストコードとは別のバージョン管理された場所に保存されます

## 現在の統合テストの状況

現在、統合テストは開発中に手動で実行されています。専用の`tests/`ディレクトリにおける正式な統合テストは計画されていますが、まだ実装されていません。一部の統合テストはソースファイル内の`#[cfg(test)]`ブロック内のモジュールレベルテストの一部として実装されています。

### 現在の統合テストアプローチ

現在の統合テストは主に以下を通じて実行されています：

1. **モジュール内統合テスト**：一部のモジュールは、ユニットテストブロック内で他のモジュールとの相互作用をテストします
2. **手動テスト**：開発者は開発中に手動で統合ポイントをテストします
3. **CLIコマンド実行**：CLIコマンド実行を通じてエンドツーエンドの機能をテストします

### 暫定的な統合テストの例

ユニットテスト内でモジュール間の統合をテストする例：

```rust
// ユニットテストブロック内の統合テストの例
#[test]
fn test_subtitle_parsing_integration() {
    // 一時的な字幕ファイルを作成
    let file = create_temp_srt_file();
    let path = file.path();
    
    // パーサーを使用して字幕ファイルを解析
    let track = parse_subtitle_file(path, None).unwrap();
    
    // 正しい解析を検証
    assert_eq!(track.len(), 3);
    
    // 時間ユーティリティとの統合を検証
    let first = track.get_subtitle_at_index(0).unwrap();
    assert_eq!(first.get_start_time().as_seconds(), 1.0);
    assert_eq!(first.get_end_time().as_seconds(), 4.0);
}
```

## 計画されている主要な統合テスト領域

### 1. コマンド実行フロー

これらのテストはエンドツーエンドのコマンド実行フローを検証します：

- **コマンドラインから実行まで**：
  - 引数をコマンドに解析するテスト
  - 引数によるコマンド初期化の検証
  - エンドツーエンド実行フローのテスト

- **パイプライン統合**：
  - CLIと処理パイプライン間の相互作用テスト
  - コンテキスト作成と受け渡しの検証
  - 操作からCLIへの進捗報告のテスト

### 2. FFmpeg統合

これらのテストはFFmpegとの相互作用に焦点を当てます：

- **コマンド生成と実行**：
  - FFmpegコマンドの生成と実行のテスト
  - パラメータ処理とエスケープの検証
  - エラー処理とステータス報告のテスト

- **メディア情報抽出**：
  - メディア情報のためのFFmpeg出力解析のテスト
  - 異なるファイルフォーマットの処理の検証
  - 無効なメディアファイルでのエラー条件のテスト

### 3. 字幕処理統合

これらのテストは字幕処理能力を検証します：

- **フォーマット変換**：
  - 異なる字幕フォーマット間の変換のテスト
  - 文字エンコーディング処理の検証
  - オーディオ/ビデオコンテンツとの同期のテスト

## 実装計画

統合テストは段階的に実装されます：

### フェーズ1：テストインフラストラクチャ（2024年第2四半期）

- `tests/`ディレクトリ構造のセットアップ
- テストユーティリティとヘルパー関数の作成
- メディアファイルテストフィクスチャの確立
- 基本的なテストランナー設定の実装

### フェーズ2：コア統合テスト（2024年第3四半期）

- CLIとFFmpeg統合のテスト実装
- 処理パイプラインと操作のテスト作成
- ファイル処理とユーティリティ統合のテスト

### フェーズ3：高度な統合テスト（2024年第4四半期）

- 複雑なワークフローのテスト実装
- エラー処理と回復のテスト作成
- 統合されたコンポーネントのパフォーマンス特性のテスト

## 統合テストのベストプラクティス

1. **焦点を絞ったスコープ**：コンポーネント間の特定の相互作用をテスト
2. **実際の依存関係**：実用的な場合は実際の依存関係を使用
3. **独立したテストケース**：テスト同士が干渉しないことを確保
4. **現実的なデータ**：現実的なメディアファイルと入力を使用
5. **エラー処理**：エラーケースと回復シナリオをテスト
6. **パフォーマンスの考慮**：リソース使用量とテスト期間を考慮

## 結論

正式な統合テストはまだ完全に実装されていませんが、edvプロジェクトはコンポーネントの相互作用を検証することの重要性を認識しています。計画されている統合テストアプローチは、プロジェクトが進化し続ける中でモジュール間の信頼性の高い相互作用を確保します。 
# edv - テストツールと自動化

このドキュメントでは、一貫性のある信頼性の高いテストを確保するために、edvプロジェクトで計画されているテストツール、フレームワーク、および自動化アプローチについて概説します。

## テストツールとフレームワーク

### Rustテストツール

edvプロジェクトは、Rustの組み込みテスト機能といくつかの専門的なテストツールを活用しています：

- **組み込みテストフレームワーク**：
  - ユニットテストと統合テストにRustの組み込み`#[test]`属性を使用
  - `#[cfg(test)]`モジュールなどのテスト編成機能を活用
  - 標準のアサーションマクロ（`assert!`、`assert_eq!`など）を採用

- **テストランナー**：
  - ユニットテストと統合テストの実行に`cargo test`を使用
  - テスト出力のデバッグに`cargo test -- --nocapture`を採用
  - 特定のテストやテストグループを実行するためのテストフィルターを使用

- **モック**：
  - モックオブジェクト作成に`mockall`を使用
  - 外部依存関係のモック実装を作成
  - 相互作用パターンを検証するためのモック期待値を使用

- **アサーション**：
  - 基本的なチェックに標準Rustアサーションを使用
  - ドメイン固有の検証にカスタムアサーションマクロを採用
  - 共通のアサーションパターン用のヘルパー関数を実装

- **コードカバレッジ**：
  - Linuxでのコードカバレッジ測定に`tarpaulin`を使用
  - すべてのプラットフォームでのカバレッジに`grcov`を採用
  - カバレッジ目標を設定し進捗を追跡

### パフォーマンステストツール

パフォーマンステストについて、edvプロジェクトでは専門的なベンチマークとプロファイリングツールを使用する計画です：

- **ベンチマーク**：
  - 信頼性の高い統計的ベンチマークに`criterion`を使用
  - 関連する操作のベンチマークグループを作成
  - スケーリング特性をテストするためのパラメトリックベンチマークを実装

- **プロファイリング**：
  - CPUプロファイリングとホットスポット識別に`flamegraph`を使用
  - Linux上での低レベルパフォーマンス分析に`perf`を採用
  - パフォーマンスボトルネックを特定するためのサンプリングプロファイラを使用

- **メモリ分析**：
  - Linuxでのメモリプロファイリングに`valgrind`と`DHAT`を使用
  - アロケーションパターン用のカスタムメモリ追跡を採用
  - メモリ使用量メトリクスと追跡を実装

- **継続的モニタリング**：
  - CI全体でビルド間のパフォーマンスメトリクスを追跡
  - パフォーマンス変更の回帰検出を実装
  - 傾向分析用のパフォーマンスダッシュボードを作成

### テストデータ管理

信頼性の高いテストには効果的なテストデータ管理が不可欠です：

- **テストフィクスチャ**：
  - 既知の特性を持つテストビデオファイルのコレクションを維持
  - バージョン管理された場所にフィクスチャを保存
  - 対象を絞った選択のためのフィクスチャに関するメタデータを含める

- **生成コンテンツ**：
  - 特定のテストケース用の合成ビデオコンテンツを作成
  - 制御されたプロパティを持つ標準化されたテストファイルを生成
  - 再現可能なテスト用に決定論的に生成されたコンテンツを使用

- **参照出力**：
  - 比較のための参照出力を保存
  - チェックサムや他の検証メカニズムを使用
  - バージョン管理に参照出力を含める

- **大きなファイルのテスト**：
  - ストレステスト用の大きなファイルのサブセットを含める
  - バージョン管理外に大きなファイルを保存
  - 必要に応じてテスト資産の自動ダウンロードを実装

## テスト自動化計画

### 継続的インテグレーション

計画されたテスト自動化戦略は、継続的な検証を確保するためにCI/CDパイプラインと統合されます：

- **PR検証**：
  - すべてのPRに対してユニットテストと高速統合テストを実行
  - リンティングとスタイルチェックを実行
  - テストレポートを生成して公開

- **ナイトリービルド**：
  - パフォーマンステストを含む完全なテストスイートを実行
  - 包括的なカバレッジレポートを生成
  - プラットフォーム全体でシステムテストを実行

- **クロスプラットフォームテスト**：
  - Linux、macOS、およびWindowsでテスト
  - 異なるCPUアーキテクチャで検証
  - 異なるFFmpegバージョンでテスト

- **結果レポート**：
  - テストレポートと傾向分析を生成
  - 時間の経過に伴うカバレッジを追跡
  - ビルド間でパフォーマンスメトリクスを監視

### 計画されているCI構成

以下のGitHub Actionsワークフローの実装が計画されています：

```yaml
name: Test Suite

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable]

    steps:
    - uses: actions/checkout@v2
    
    - name: Install FFmpeg
      uses: FedericoCarboni/setup-ffmpeg@v2
      
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ matrix.rust }}
        override: true
        components: rustfmt, clippy
        
    - name: Check formatting
      uses: actions-rs/cargo@v1
      with:
        command: fmt
        args: --all -- --check
        
    - name: Clippy
      uses: actions-rs/cargo@v1
      with:
        command: clippy
        args: -- -D warnings
        
    - name: Build
      uses: actions-rs/cargo@v1
      with:
        command: build
        
    - name: Run unit tests
      uses: actions-rs/cargo@v1
      with:
        command: test
        args: --lib
        
    - name: Run integration tests
      uses: actions-rs/cargo@v1
      with:
        command: test
        args: --test '*'
```

### 計画されている高度なCI機能

基本的なテストに加えて、CIシステムにはいくつかの高度な機能が実装される予定です：

- **テストマトリックス**：
  - 複数のOSとRustバージョンをテスト
  - 異なるFFmpegバージョンをテスト
  - 異なるコンパイラ構成で検証

- **並列化**：
  - 独立したテストを並列に実行
  - ランナー間でテストを分散
  - テスト実行順序を最適化

- **キャッシング**：
  - 実行間でRust依存関係をキャッシュ
  - より高速なビルドのためにビルドアーティファクトをキャッシュ
  - 繰り返しダウンロードを避けるためにテストフィクスチャを保存

- **スケジュールされたテスト**：
  - スケジュールに従って完全なテストスイートを実行
  - 定期的にパフォーマンスベンチマークを実行
  - 最新の依存関係に対してテスト

### ローカルテスト自動化

ローカル開発用に、いくつかのスクリプトとツールが計画されています：

- **テストヘルパー**：
  - 一般的なテストシナリオ実行用のスクリプト
  - テスト環境のセットアップ用のヘルパー
  - テスト結果分析用のツール

- **プリコミットフック**：
  - コミット前にユニットテストを実行
  - リンティングとフォーマットチェックを実行
  - コミットメッセージを検証

- **開発ワークフロー**：
  - IDEテストランナーとの統合
  - 開発中の継続的テスト用のウォッチモード
  - TDDワークフロー用の高速フィードバックループ

## テストドキュメント

### テスト計画

各主要機能について、以下を含むテスト計画を作成します：

- **テスト目標**：
  - 検証すべき内容を定義
  - 受け入れ基準を設定
  - テストの範囲と境界を確立

- **テストケース**：
  - テスト入力と期待される出力を文書化
  - ステップバイステップのテスト手順を作成
  - テストデータ要件を特定

- **エッジケースとエラー条件**：
  - テストする境界条件をリスト
  - 期待されるエラー動作を文書化
  - 潜在的な障害モードを特定

- **パフォーマンス期待値**：
  - パフォーマンス目標を設定
  - 許容可能なパフォーマンス範囲を定義
  - リソース要件を文書化

### テストレポート

以下を含むテストレポートを生成します：

- **テストカバレッジメトリクス**：
  - ラインおよびブランチカバレッジ統計
  - カバーされていないコード領域
  - 時間の経過に伴うカバレッジの傾向

- **テスト結果の概要**：
  - 合格/不合格統計
  - テスト実行時間
  - 特定された重要な問題

- **パフォーマンスベンチマーク結果**：
  - パフォーマンス測定結果
  - ベースラインとの比較
  - パフォーマンスの傾向

- **問題と推奨事項**：
  - 発見された問題を文書化
  - 改善を提案
  - フォローアップアクションの優先順位付け

## 自動テスト実行

以下の図は、計画された自動テスト実行フローを示しています：

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│             │     │             │     │             │
│ ユニットテスト │────►│  統合テスト  │────►│ システムテスト │
│             │     │             │     │             │
│             │     │             │     │             │
└─────────────┘     └─────────────┘     └─────────────┘
       │                  │                   │
       │                  │                   │
       ▼                  ▼                   ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│             │     │             │     │             │
│ カバレッジ   │     │ パフォーマンス │     │ プラットフォーム│
│  レポート    │     │ ベンチマーク  │     │   テスト     │
│             │     │             │     │             │
└─────────────┘     └─────────────┘     └─────────────┘
       │                  │                   │
       │                  │                   │
       └──────────────────┼───────────────────┘
                          │
                          ▼
                    ┌─────────────┐
                    │             │
                    │ テストレポート│
                    │   生成      │
                    │             │
                    └─────────────┘
                          │
                          ▼
                    ┌─────────────┐
                    │             │
                    │ 通知とアラート │
                    │             │
                    │             │
                    └─────────────┘
```

## テストスケジュール

テスト活動は開発ライフサイクル全体に統合されます：

- **設計フェーズ**：
  - 初期テスト計画を作成
  - テスト可能性要件を作成
  - テストのための設計

- **実装フェーズ**：
  - コードと共にユニットテストを作成（TDD）
  - 継続的テストを実行
  - テストカバレッジを追跡

- **機能完了**：
  - 統合テストを追加
  - 完全なテストスイートを実行
  - 要件に対して検証

- **リリース前**：
  - システムテストを実施
  - パフォーマンスベンチマークを実行
  - 回帰テストを実施

- **メンテナンス**：
  - 回帰テストを継続
  - 新機能用のテストを更新
  - テストスイートを維持および改善

このテストツールと自動化に対する包括的なアプローチにより、edvプロジェクトは継続的な検証と効率的なテスト実践を通じて高品質を維持します。

## 実装状況更新（2024年3月）

2024年3月の時点で、テストツールと自動化の実装は初期段階にあります：

### テストツール実装状況

| ツールカテゴリ | 状況 | 実装レベル | 展開されたツール |
|---------------|--------|----------------------|----------------|
| テストフレームワーク | 🔄 進行中 | 60% | Rust test, cargo-test |
| モック | 🔄 進行中 | 40% | 基本的なモック実装 |
| コードカバレッジ | 🟠 計画中 | 15% | tarpaulinの初期調査 |
| ベンチマーク | 🟠 計画中 | 10% | criterionの実装を計画 |
| プロファイリング | 🟠 計画中 | 5% | 調査段階 |
| ファズテスト | 🟠 計画中 | 0% | 未開始 |
| テストデータ管理 | 🔄 進行中 | 30% | 基本的なテストフィクスチャ作成済み |

### CI/CDパイプライン状況

| パイプラインコンポーネント | 状況 | 実装レベル | 詳細 |
|-------------------|--------|----------------------|---------|
| ビルド検証 | 🟠 計画中 | 15% | ローカルビルド検証のみ |
| ユニットテスト自動化 | 🟠 計画中 | 20% | 手動テスト実行、CI向けに計画 |
| 統合テスト自動化 | 🟠 計画中 | 10% | 基本構造定義済み |
| システムテスト自動化 | 🟠 計画中 | 5% | 計画段階 |
| パフォーマンス回帰 | 🟠 計画中 | 0% | 未開始 |
| テストレポート | 🟠 計画中 | 5% | 基本概念定義済み |
| クロスプラットフォームテスト | 🟠 計画中 | 10% | 異なるプラットフォームでの手動テスト |

### 現在のテストアプローチ

1. **手動テストプロセス**
   - 現在は`cargo test`での手動テスト実行を使用
   - コアコンポーネント用の基本的なユニットテスト作成済み
   - 異なるプラットフォームでの手動検証
   - アドホックなパフォーマンステスト

2. **テストデータ管理**
   - テストメディアファイルの小規模コレクション
   - 出力の手動検証
   - 基本的なテスト入出力検証

3. **テストドキュメント**
   - 主要コンポーネントのテスト計画
   - テストアプローチの文書化
   - テスト作成のためのガイドライン

### テストツールの現在の使用状況

1. **ユニットテスト**
   - Rustの組み込みテストフレームワークを使用
   - 機能検証のための基本的なアサーション
   - `#[cfg(test)]`モジュールを使用したテスト編成
   - ユニットテストの例：

   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       
       #[test]
       fn test_time_conversion() {
           let tc = Timecode::from_seconds(3600.5);
           assert_eq!(tc.to_string(), "01:00:00.500");
           assert_eq!(tc.to_seconds(), 3600.5);
       }
   }
   ```

2. **基本的な統合テスト**
   - モジュール間の限定的な統合テスト
   - モジュール相互作用の手動検証
   - 統合テストの例：

   ```rust
   #[cfg(test)]
   mod integration_tests {
       use crate::cli::commands::TrimCommand;
       use crate::processing::trim::TrimOperation;
       
       #[test]
       fn test_trim_command_to_operation() {
           let cmd = TrimCommand::new();
           cmd.set_input("input.mp4");
           cmd.set_output("output.mp4");
           cmd.set_start("00:00:10");
           cmd.set_end("00:01:00");
           
           let op = cmd.create_operation().unwrap();
           assert_eq!(op.input_path, "input.mp4");
           assert_eq!(op.start_time.to_seconds(), 10.0);
           assert_eq!(op.end_time.to_seconds(), 60.0);
       }
   }
   ```

### テスト実装における課題

1. **テストデータ管理**
   - **課題**：テストメディアファイルの作成と管理
   - **現在のアプローチ**：手動で作成された小規模なテストファイルセット
   - **計画**：包括的なテストデータ管理システムを開発

2. **クロスプラットフォームテスト**
   - **課題**：プラットフォーム間での一貫した動作の確保
   - **現在のアプローチ**：利用可能なプラットフォームでの手動テスト
   - **計画**：プラットフォームマトリックスを持つCIを実装

3. **FFmpeg統合テスト**
   - **課題**：FFmpegとの相互作用を確実にテスト
   - **現在のアプローチ**：基本的なコマンド検証
   - **計画**：包括的なFFmpegモックシステムを開発

### テスト自動化ロードマップ（2024-2025）

1. **2024年第2四半期：基本的なCIセットアップ**
   - 基本的なビルド検証のためのGitHub Actionsを実装
   - 自動ユニットテスト実行をセットアップ
   - コードスタイルチェック（rustfmt、clippy）を実装

2. **2024年第3四半期：強化されたテストツール**
   - コードカバレッジ追跡を実装
   - 外部依存関係用のモックフレームワークをセットアップ
   - 基本的な統合テスト自動化を開発

3. **2024年第4四半期：パフォーマンステスト**
   - ベンチマークフレームワークを実装
   - パフォーマンス回帰テストをセットアップ
   - パフォーマンステストレポートを作成

4. **2025年第1四半期：完全なテスト自動化**
   - CI/CDパイプラインの実装を完了
   - クロスプラットフォームテストマトリックスを実装
   - 包括的なテストレポートを開発

テストツールと自動化インフラストラクチャは、特に活発に開発中のモジュールをサポートし、将来のテストニーズのための堅固な基盤を確立することに焦点を当てて、進化し続けます。 
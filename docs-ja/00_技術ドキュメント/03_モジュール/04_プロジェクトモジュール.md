# edv - プロジェクトモジュール実装

このドキュメントでは、edvアプリケーションのプロジェクトモジュールの詳細な実装ガイドラインを提供します。

## 概要

プロジェクトモジュールは、ビデオ編集プロジェクトデータの管理を担当する中心的なコンポーネントです。これには以下が含まれます：
- メインの`Project`構造体の定義。
- プロジェクトメタデータ（名前、作成/変更日時など）の処理。
- プロジェクトアセット（ビデオ、オーディオ、画像ファイル）の管理。
- コアとなる`Timeline`データ構造と編集機能（トラック、クリップ、関係性、履歴）の提供。
- JSONフォーマットでのプロジェクトシリアル化（保存/読み込み）の実装。
- プロジェクトタイムラインのレンダリングプロセスの調整。

## 構造

プロジェクトモジュールは以下のように構成されています：

```
src/project/
├── mod.rs             # モジュールエクスポート、Project構造体、Asset*、ProjectMetadata、ProjectId、ProjectError
├── timeline/          # タイムライン編集機能
│   ├── mod.rs         # Timeline、Track、Clip構造体、コア編集メソッド（追加/削除/分割/結合/移動）
│   ├── multi_track.rs # MultiTrackManager、TrackRelationship、依存関係管理
│   └── history.rs     # EditHistory、EditAction、TransactionGroup、元に戻す/やり直すロジック
├── rendering/         # プロジェクトレンダリング機能
│   ├── mod.rs         # レンダリングモジュールのエクスポート、RenderError
│   ├── config.rs      # RenderConfig、VideoCodec、AudioCodec、OutputFormat
│   ├── compositor.rs  # TrackCompositor、トラック準備と合成ロジック（FFmpegプレースホルダーを使用）
│   ├── pipeline.rs    # RenderPipeline、RenderResult、同期/非同期レンダリング実行
│   └── progress.rs    # RenderProgress、RenderStage、SharedProgressTracker
└── serialization/     # プロジェクトシリアル化機能
    ├── mod.rs         # シリアル化モジュールのエクスポート
    └── json.rs        # JSONシリアライザ/デシリアライザ、Serialized*構造体
```

**注意:** アセット管理タイプ（`AssetId`、`AssetReference`、`AssetMetadata`）は、別の`asset`モジュールではなく、`src/project/mod.rs`内で定義されています。

## 主要コンポーネント

### プロジェクト構造（`mod.rs`）

コアとなる`Project`構造体はすべてのプロジェクト関連データを保持します：

```rust
pub struct Project {
    /// プロジェクトの名前（project_metadata.nameにも含まれる）。
    pub name: String,
    /// プロジェクトのタイムライン。
    pub timeline: timeline::Timeline,
    /// プロジェクトで使用されるアセット。
    pub assets: Vec<AssetReference>,
    /// 追加のメタデータ（現在未使用、削除するかProjectMetadataに統合することを検討）。
    pub metadata: std::collections::HashMap<String, String>,
    /// プロジェクトメタデータ（名前、タイムスタンプ、説明、タグ）。
    pub project_metadata: ProjectMetadata,
}

impl Project {
    /// 指定された名前で新しい空のプロジェクトを作成します。
    pub fn new(name: &str) -> Self { /* ... */ }

    /// アセット（そのパスとメタデータで表される）をプロジェクトに追加します。
    /// 新しく生成されたAssetIdを返します。
    pub fn add_asset(&mut self, path: PathBuf, metadata: AssetMetadata) -> AssetId { /* ... */ }

    /// IDによってアセットへの不変参照を取得します。
    pub fn get_asset(&self, id: AssetId) -> Option<&AssetReference> { /* ... */ }

    /// IDによってアセットへの可変参照を取得します。
    pub fn get_asset_mut(&mut self, id: AssetId) -> Option<&mut AssetReference> { /* ... */ }

    /// IDによってプロジェクトからアセットを削除します。
    /// `Ok(())`または`ProjectError::AssetNotFound`を返します。
    pub fn remove_asset(&mut self, id: AssetId) -> Result<()> { /* ... */ }

    /// シリアル化モジュールを使用してプロジェクトをJSONファイルに保存します。
    /// 保存前に変更タイムスタンプを更新します。
    pub fn save(&self, path: &std::path::Path) -> Result<()> { /* ... */ }

    /// シリアル化モジュールを使用してJSONファイルからプロジェクトを読み込みます。
    pub fn load(path: &std::path::Path) -> Result<Self> { /* ... */ }

    /// レンダリングモジュールを介してデフォルト設定でプロジェクトをビデオファイルにレンダリングします。
    pub fn render(&self, output_path: &std::path::Path) -> Result<rendering::RenderResult> { /* ... */ }

    /// レンダリングモジュールを介して指定された設定でプロジェクトをレンダリングします。
    pub fn render_with_config(
        &self,
        config: rendering::RenderConfig,
    ) -> Result<rendering::RenderResult> { /* ... */ }
}

// mod.rsの他の関連構造体：
pub struct ProjectId(Uuid); // プロジェクトの一意のID
pub struct ProjectMetadata { /* name, created_at, modified_at, description, tags */ }
pub struct AssetId(Uuid); // アセットの一意のID
pub struct AssetReference { /* id, path, metadata */ }
pub struct AssetMetadata { /* duration, dimensions, asset_type, extra */ }

// プロジェクトレベルのエラー列挙型
pub enum ProjectError {
    Timeline(#[from] timeline::TimelineError),
    Io(#[from] std::io::Error),
    Serialization(String),
    AssetNotFound(AssetId),
    Rendering(#[from] rendering::RenderError),
}
```

**責任：**
- 全体的なプロジェクト状態（タイムライン、アセット、メタデータ）を保持します。
- 基本的なプロジェクトライフサイクル管理（新規作成、読み込み、保存）のメソッドを提供します。
- プロジェクトで使用されるアセットのリストを管理します。
- タイムライン編集を`Timeline`構造体に委譲します。
- レンダリングを`rendering`モジュールに委譲します。
- シリアル化/デシリアル化を`serialization`モジュールに委譲します。
- **注意：** 編集履歴を直接管理しません（`EditHistory`は`timeline`モジュールの一部です）。

### タイムライン編集（`timeline/mod.rs`、`timeline/multi_track.rs`、`timeline/history.rs`）

これは編集機能の中核です。

#### タイムライン構造（`timeline/mod.rs`）

```rust
// トラック上の単一のクリップを表す
pub struct Clip {
    id: ClipId,
    asset_id: AssetId,
    position: TimePosition,  // タイムライン上の開始時間
    duration: Duration,
    source_start: TimePosition, // ソースアセット内の開始時間
    source_end: TimePosition,   // ソースアセット内の終了時間
}
impl Clip {
    // メソッド：new、id、asset_id、position、end_position、duration、
    //          source_start、source_end、set_*、overlaps_with
}

// 単一のトラック（ビデオ、オーディオ、字幕）を表す
pub enum TrackKind { Video, Audio, Subtitle }
pub struct Track {
    id: TrackId,
    kind: TrackKind,
    name: String,
    clips: Vec<Clip>, // 位置でソート
    muted: bool,
    locked: bool,
}
impl Track {
    // メソッド：new、id、kind、name、set_name、is_muted、set_muted、
    //          is_locked、set_locked、get_clips、get_clips_mut、
    //          get_clip、get_clip_mut、add_clip（重複チェック、ソート）、
    //          remove_clip、duration（最後のクリップの終了に基づいて計算）
}

// 複数のトラックを持つ全体のタイムラインを表す
pub struct Timeline {
    tracks: Vec<Track>,
    multi_track_manager: multi_track::MultiTrackManager,
}
impl Timeline {
    // メソッド：new、get_tracks、get_track、get_track_mut、has_track、
    //          find_track_containing_clip、add_track、remove_track（マネージャーを更新）、
    //          add_clip（Trackに委譲）、remove_clip（Trackに委譲）、
    //          multi_track_manager、multi_track_manager_mut、duration（最長トラックに基づいて計算）、
    //          split_clip、merge_clips、move_clip_to_track
}

// タイムライン固有のエラー列挙型
pub enum TimelineError {
    TrackNotFound(TrackId),
    ClipNotFound { track: TrackId, clip: ClipId },
    ClipOverlap { position: TimePosition },
    MultiTrack(#[from] multi_track::MultiTrackError),
    InvalidOperation(String),
}
```
**責任：**
- `Timeline`、`Track`、および`Clip`データ構造を定義します。
- トラックとクリップの追加、削除、およびクエリのためのメソッドを提供します。
- コア編集操作を実装します：`split_clip`、`merge_clips`、`move_clip_to_track`。
- トラック内のクリップの順序を管理します。
- クリップの重複や無効な操作などの潜在的なエラーを処理します。
- マルチトラック関係の管理を`MultiTrackManager`に委譲します。

#### マルチトラック関係（`timeline/multi_track.rs`）

```rust
pub enum TrackRelationship { Independent, Locked, TimingDependent, VisibilityDependent }

pub struct MultiTrackManager {
    dependencies: HashMap<TrackId, HashMap<TrackId, TrackRelationship>>,
    reverse_dependencies: HashMap<TrackId, HashSet<TrackId>>,
}
impl MultiTrackManager {
    // メソッド：new、add_relationship（循環チェック）、remove_relationship、
    //          get_dependent_tracks、get_track_dependencies、get_relationship、
    //          apply_edit（変更を伝播）、remove_track、
    //          would_create_circular_dependency、is_dependent_on、
    //          propagate_changes（関係タイプに基づく再帰的伝播）、
    //          synchronize_locked_tracks、update_timing_dependent_track、
    //          update_visibility_dependent_track
}

// マルチトラック固有のエラー列挙型
pub enum MultiTrackError { TrackNotFound(TrackId), CircularDependency(TrackId, TrackId), /* ... */ }
```
**責任：**
- トラック間の依存関係と関係（`Locked`、`TimingDependent`など）を管理します。
- 循環依存関係を検出し、防止します。
- あるトラックに加えられた変更を、関係のタイプに基づいて依存トラックに伝播します。
- トラックの依存関係を照会するためのメソッドを提供します。

#### 編集履歴（`timeline/history.rs`）

```rust
pub enum EditAction { /* AddClip, RemoveClip, MoveClip, SetClipDuration, ..., AddRelationship, ... */ }
pub trait UndoableAction { fn apply(...); fn undo(...); }
impl UndoableAction for EditAction { /* ... */ }

pub struct TransactionGroup { description: Option<String>, actions: Vec<EditAction> }
pub enum HistoryEntry { Single(EditAction), Group(TransactionGroup) }

pub struct EditHistory {
    undo_stack: Vec<HistoryEntry>,
    redo_stack: Vec<HistoryEntry>,
    current_transaction: Option<TransactionGroup>,
    capacity: Option<usize>,
}
impl EditHistory {
    // メソッド：new、begin_transaction、commit_transaction、rollback_transaction、
    //          record_action、push_entry（容量を処理）、undo、redo、
    //          can_undo、can_redo、clear、undo_stack、redo_stack
}

// 履歴固有のエラー列挙型
pub enum HistoryError { NothingToUndo, NothingToRedo, ApplyActionError(String), /* ... */ }
```
**責任：**
- `EditAction`を使用してタイムライン編集操作を追跡します。
- 個々のアクションとトランザクションに対する元に戻す（`undo`）およびやり直す（`redo`）機能を実装します。
- 複数のアクションを原子的な`TransactionGroup`にグループ化することをサポートします。
- 元に戻すスタックとやり直すスタックを管理します。
- 元に戻す/やり直し操作中の潜在的なエラーを処理します。

### レンダリング（`rendering/`）

プロジェクトタイムラインを最終的なビデオファイルにレンダリングするプロセスを処理します。

```rust
// レンダリングの設定
pub struct RenderConfig { /* output_path, width, height, frame_rate, codecs, quality, format, range, threads, ... */ }
pub enum VideoCodec { H264, H265, VP9, ProRes, Copy }
pub enum AudioCodec { AAC, MP3, Opus, FLAC, Copy }
pub enum OutputFormat { MP4, WebM, MOV, MKV }

// トラックの合成を管理
pub struct TrackCompositor { /* timeline, assets, intermediate_files, progress */ }
impl TrackCompositor {
    // メソッド：new、set_progress_tracker、prepare_tracks（FFmpegプレースホルダーを介して中間ファイルを作成）、
    //          composite_tracks（FFmpegプレースホルダーを介して中間ファイルを結合）、compose（主要なエントリーポイント）
}

// 全体的なレンダリングパイプラインを管理
pub struct RenderPipeline { /* project, config, progress, start_time */ }
impl RenderPipeline {
    // メソッド：new、set_progress_callback、render（同期）、render_async（非同期）、cancel、get_progress
}

// レンダリングの進捗を表す
pub struct RenderProgress { /* total_frames, completed, position, duration, elapsed, estimated, fps, stage */ }
pub enum RenderStage { Preparing, RenderingVideo, ProcessingAudio, Muxing, Finalizing, Complete, Failed, Cancelled }
pub struct SharedProgressTracker { /* Arc<Mutex<ProgressTracker>> */ }

// レンダリング固有のエラー列挙型
pub enum RenderError { FFmpeg(String), Composition(String), Io(String), Timeline(String), Cancelled }
```
**責任：**
- レンダリング設定オプション（`RenderConfig`）を定義します。
- 異なるステージを調整するレンダリングパイプライン（`RenderPipeline`）を実装します。
- トラック合成（`TrackCompositor`）を処理し、現在は各トラックの中間ファイルを作成し、それらを多重化するための実際のFFmpeg呼び出しのプレースホルダーを使用しています。
- 進捗追跡（`RenderProgress`、`SharedProgressTracker`）とキャンセルサポートを提供します。
- レンダリング固有のエラー（`RenderError`）を定義します。

### シリアル化（`serialization/`）

プロジェクト状態のファイルへの保存と読み込みを処理します。

```rust
// プロジェクト構造の中間シリアル化可能表現
struct SerializedProject { /* ... */ }
struct SerializedTimeline { /* ... */ }
// ... および他のSerialized*構造体

// メインシリアル化関数（現在はJSONのみ）
pub fn serialize_project(project: &Project, path: &Path) -> Result<()> { /* ... */ }
pub fn deserialize_project(path: &Path) -> Result<Project> { /* ... */ }

// シリアル化固有のエラー列挙型
pub enum SerializationError { Io(#[from] std::io::Error), Json(#[from] serde_json::Error), IncompatibleFormat(String), UnsupportedVersion(String), /* ... */ }
```
**責任：**
- 中間`Serialized*`構造体を使用して`Project`状態（タイムライン、アセット、メタデータを含む）をJSONフォーマットにシリアル化します。
- JSONファイルからプロジェクトデータを`Project`インスタンスに戻すデシリアル化を行います。
- デシリアル化中のバージョンチェックとフォーマット検証を処理します。
- シリアル化固有のエラー（`SerializationError`）を定義します。
- **注意：** バイナリシリアル化はコメントで言及されていますが、実装されていません。

## 依存関係

- `Project`は`Timeline`、`AssetReference`、`ProjectMetadata`を使用します。
- `Timeline`は`Track`、`Clip`、`MultiTrackManager`を使用します。
- `Track`は`Clip`を使用します。
- `EditHistory`は`EditAction`、`TransactionGroup`、`Timeline`を使用します。
- `RenderPipeline`は`Project`、`RenderConfig`、`TrackCompositor`、`SharedProgressTracker`を使用します。
- `TrackCompositor`は`Timeline`、`AssetReference`、`RenderConfig`、`SharedProgressTracker`、および（将来的に）`ffmpeg`を使用します。
- `Project`は`serialize_project` / `deserialize_project`を使用します。
- `Serialization`は`Project`とそのすべてのネストされた構造（`Serialized*`表現を介して）および`serde_json`を使用します。

## 実装の詳細

- **ID:** 一意の識別のためにnewtype（`ProjectId`、`AssetId`、`ClipId`、`TrackId`）でラップされた`Uuid`を使用します。
- **時間:** カスタム`TimePosition`と`Duration`タイプを使用します（おそらく`utility`モジュールから、確認が必要）。
- **エラー処理:** 各関連サブモジュール（`ProjectError`、`TimelineError`、`MultiTrackError`、`HistoryError`、`RenderError`、`SerializationError`）でカスタムエラー列挙型を定義するために`thiserror`を使用します。`Result`型エイリアスが提供されています。
- **不変性/可変性:** Rustの借用ルールに従います。可変メソッドはしばしば`modified`フラグを設定します（例：`SubtitleEditor`内、Project/Timelineが同様のフラグを使用するかチェックが必要）。編集履歴アクションは変更を元に戻すために必要なデータを保存します。
- **FFmpeg操作:** 主に`rendering`モジュール内（現在はプレースホルダー）でトラックの構成と最終出力のために処理されます。

## 将来の拡張（コード分析から）

- `TrackCompositor`でトラック準備と最終多重化のための実際のFFmpeg呼び出しを実装します。
- `timeline/history.rs`に`SplitClip`と`MergeClips`の`EditAction`バリアントを追加し、それらの`apply`/`undo`を実装します。
- `serialization/`でバイナリシリアル化フォーマットの実装を検討します。
- より複雑なシナリオのために`timeline/multi_track.rs`の`update_timing_dependent_track`と`update_visibility_dependent_track`を改良します。
- `SubtitleEditor::fix_overlaps`で`remove`戦略を実装します。
- 潜在的に`Project::metadata`を`ProjectMetadata`と統合します。

この更新されたドキュメントは、最後のコードレビュー時点での`src/project/`ディレクトリの構造と主要コンポーネントを反映しています。 